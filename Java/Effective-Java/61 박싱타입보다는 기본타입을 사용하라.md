# 61. 박싱타입보다는 기본타입을 사용하라

Created: 2021년 5월 23일
Created by: Seha Jyang

기본타입과 박싱된기본타입의 차이는 크게 세가지다.

- 기본 타입은 값만 가지지만 박싱기본타입은 인스턴스 값이 다르면 서로 다르다고 식별한다.
- 기본타입의 값은 언제나 유효하나 박싱기본타입은 null을 가질 수 있다.
- 기본타입이 박싱기본타입보다 시간과 메모리 사용면에서 더 효율적이다.

이러한 차이 때문에 주의하지 않고 사용하면 문제가 발생한다.

```java
Comparator<Integer> order =
  (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

order.compare(new Integer(42), new Integer(42)); // expect : 0, actual : 1
// i 와 j가 서로 다른 Integer 인스턴스라면 i == j 는 false이 되고 1을 리턴한다.
```

**박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다**

실무에서 이런 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()` 를 사용하자.

비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다.

```java
public class Unbelievable {
  static Integer i;
  main() {
     if (i == 42) print("!!");
  }
}
// 이 코드는 i == 42를 검사할때 NPE를 발생시킨다.
```

**기본 타입과 박싱된기본타입을 혼용한 연산에선 박싱된 기본 타입의 박싱이 자동으로 풀린다**

```java
// 이 코드는 지역변수 sum을 박싱된 기본타입으로 선언해서 느려졌다.
// 박싱과 언박싱이 반복해서 일어나기 때문이다.
main() {
  Long sum = 0L;
  for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    sum += i;
  }
  print(sum);
}
```

박싱된 기본타입은 다음과 같을때에 사용되어야 한다.

- 컬렉션의 원소, 키, 값으로 쓴다.
    - 컬렉션은 기본 타입을 담을 수 없으므로 박싱된 기본타입을 써야한다.
    - 파라미터화 타입이나, 파라미터화 메서드[(item5)](5%20%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%B5%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%86%E1%85%A7%E1%86%BC%E1%84%89%E1%85%B5%E1%84%92%E1%85%A1%E1%84%8C%E1%85%B5%20%E1%84%86%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%AE%E1%84%8B%E1%85%B5%20f474ba4b468242518b6a114356cc8159.md)의 타입 파라미터로는 박싱된 기본 타입을 써야한다. 자바가 지원하지 않기 때문
- 리플렉션을 통해 메서드를 호출할 때도(item 65) 박싱된 기본타입을 써야한다.

## 정리

기본타입과 박싱된기본타입 둘중 하나를 써야 한다면 기본타입을 사용하라. 간단하고 빠르기 때문. 

- 박싱타입을 쓸땐 주의를 기울이자. **오토박싱이 박싱된 기본 타입을 사용할때의 번거로움을 줄여주지만, 그 위험을 없애진앖는다.**
- 박싱된기본타입을 ==로 비교하면 안된다.
- 같은 연산에서 기본타입과 박싱된기본타입을 혼용하면 언박싱이 이뤄지며 언박싱과정에서 NPE를 던질 수 있다.
- 기본타입을 박싱하는 작업은 필요없는 객체를 생성하는 부작용을 낳을 수 있다.