# 81. wait 와 notify보다는 동시성 유틸리티를 애용하라

Created: 2021년 5월 27일
Created by: Seha Jyang

**wait notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자**

고수준 유틸리티는 다음과 같이 나눌 수 있다.

- 실행자 프레임워크
- 동시성 컬렉션(concurrent collection)
    - List, Queue등 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 컬렉션.
    - 동기화를 각자의 내부에서 수행한다.
    - **동시성 컬렉션에서 동시성을 무력화하는건 불가능하며 외부에서 락을 추가로 사용하면 오히려 느려진다**
    - 동시성 컬렉션은 동기화 한 컬렉션보다 좋다.
        - **Collections.synchronizedMap 보다는 ConcurrentHashMap을 사용하는게 훨씬 좋다**
- 동기화 장치(synchronizer)
    - 스레드가 다른 스레드를 기다릴 수 있게 해 서로 작업을 조율할수 있게 해준다.
    - CountDownLatch
        - 일회성
        - 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날때까지 기다리게 한다.
    - Semaphore
    - **Phaser**

시간 간격을 잴 땐 항상 **System.currentTimemillis가 아닌 System.nanoTime을 사용하자**

nanoTime은 더 정확하고 정밀하여 시스템의 실시간 시계의 시간보정에 영향받지 않는다.

**wait 메서드를 사용할땐 wait loop 관용구를 사용하라. 반복분 밖에선 절대로 호출하지 말자**

```java
synchronized(obj) {
  while(<조건이 충족되지 않았다>) 
    obj.wait(); //(락을 놓고, 깨어나면 다시 잡는다.)
  ... // 조건이 충족됐을 때의 동작을 수행한다.
}
```

만약 조건이 충족되어 있는데 스레드가 notify 메서드를 먼저 호출한 후 대기상태에 빠지면 그 스레드를 다시 깨울 수 있다고 보장할 수 없다.

대기후 조건을 검사해 조건이 충족되지 않았을 경우 다시 대기하게 하는것은 안전 실패를 막는 조치다.

조건이 충족되지 않았지만 스레드가 깨어나면 불변식을 깨트릴 위험이 있으며 다음은 그 예다.

- 스레드가 notify를 호출한 다음 대기중이던 스레드가 깨어나는 사이 다른 스레드가 락을 얻어 그 락이 보호하는 상태를 변경
- 조건이 만족되지 않았음에도 다른 스레스가 notify를 호출한다. 공개된 객체를 락으로 사용해  대기하는 클래스는 이런 위험에 노출되며 외부에 노출된 객체의 동기화된 메서드 안에서 호출하는 wait은 모두 이 문제에 영향을 받는다.
- 깨우는 스레드는 지나치게 관대해, 대기중인 스레드 일부만 조건이 충족되어도 notifyAll을 호출한다.
- 대기중인 스레드가 notify없이도 깨어나는 경우가 있다. 허위 각성(spurious wakeup)라는 현상이다.

모든 스레드가 같은 조건을 기다리고 조건이 한번 충족될때 단 하나의 스레드만 실행되어야 한다면 notifyAll대신 notify를 사용해 최적화할 수 있다. 하지만 notifyAll을 사용하면 관련 없는 스레드가 실수로 wait를 호출하는 공격으로부터 보호할 수 있다.

## 정리

**코드를 새로 작성한다면 wait와 notify를 쓸 이유가 거의 없다** 이를 사용하는 레거시 코드를 유지보수해야한다면 wait는 항상 표준 관용구에 따라 while문 안에서 호출하도록 하고 notify보단 notifyAll를 사용해야 한다. 혹시 notify를 사용한다면 응답불가 상태에 빠지지 않도록 각별히 주의하자.