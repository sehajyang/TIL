# 86. Serializable 을 구현할지는 신중히 결정하라

Created: 2021년 5월 29일
Created by: Seha Jyang

**Serializable 을 구현하면 릴리즈 한 뒤엔 수정하기 어렵다** 직렬화도니 바이트 스트림 인코딩도 하나의 공개 API가 되기 때문이다. 그래서 이 클래스가 널리 퍼진다면 그 직렬화 형태도 영원히 지원해야 되는 것이 된다. 기본 직렬화 형태에선 클래스의 private, package-private 인스턴스 필드들마저 API로 공개하는 꼴이 된다. 

그러니 직렬화 가능 클래스를 만들고자 한다면 길게 보고 감당할 수 있을만큼 주의해서 설계해야 한다.

Serializable 구현엔 다음과 같은 문제가 있다.

- 클래스 개선을 방해하게 된다.
    - **UID는 클래스멤버나 메서드가 수정된다면 함께 변경되니 UID가 자동생성된 값이고 이것에 의존하면 쉽게 호환성이 깨져버려 런타임에 InvalidClassException 이 발생하게 될 것이다**
- **버그와 보안 구멍이 생길 위험이 높아진다**
    - 역직렬화는 일반 생성자의 문제가 그대로 적용되는 '숨은 생성자'이므로 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다.
- 해당 클래스의 **신버전을 릴리즈할 때 테스트할 것이 늘어난다**
    - 양방향 직렬화/역직렬화가 모두 성공하고 원래의 객체를 충실히 복제해내는지 확인해야한다.

**Serializable 구현 여부는 가볍게 결정할 사안이 아니다**

구현에 따르는 비용이 적지 않으니 이득과 비용을 잘 저울질 해야한다.

**상속용으로 설계된 클래스는 대부분 Serializable 를 구현하면 안되며, 인터페이스도 대부분 Serializable 를 확장해선 안된다**

예외적으로 Throwable은 서버가 RMI를 통해 클라이언트로 예외를 보내기 위해 Serializable를 구현했다.

작성하는 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하며 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 반드시 하위 클래스에서 **finalize 메서드를 재정의하지 못하게 해야한다** finalize메서드를 자신이 재정의하며 final로 선언하면 된다. 이렇게 하지 않으면 finalizer공격([item8](8%20finalizer%20%E1%84%8B%E1%85%AA%20cleaner%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%91%E1%85%B5%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1%2088c955e8c73144be8c09ab38e4aaf52e.md))을 당할 수 있다. 

인스턴스 필드 값 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 다음의 `readObjectNoData` 메서드를 반드시 추가해야 한다

```java
private void readObjectNoData() throws InvalidObjectException {
 throw new InvalidObjectException("스트림 데이터 필요");
}
```

이 메서드는 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 경우를 위한 메서드다.

**내부 클래스([item24](24%20%E1%84%86%E1%85%A6%E1%86%B7%E1%84%87%E1%85%A5%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%83%E1%85%AC%E1%84%83%E1%85%A9%E1%84%85%E1%85%A9%E1%86%A8%20static%20%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%86%E1%85%A1%E1%86%AB%E1%84%83%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%2041ce6c40847b479987898deb115582f6.md)) 는 직렬화를 구현하지 말아야 한다.** 단 정적 멤버 클래스는 ****Serializable를 구현해도 된다.

## 정리

Serializable는 구현한다고 선언하긴 쉽지만 한 클래스의 여러 버전이 상호작용할 일이 없고 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등 보호된 환경에서만 쓰일 클래스가 아니라면 Serializable 구현은 아주 신중하게 이뤄져야 하며 상속할 수 있는 클래스라면 주의사항이 더욱 많아진다.