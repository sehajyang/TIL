# 82. 스레드 안전성 수준을 문서화하라

Created: 2021년 5월 27일
Created by: Seha Jyang

메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일뿐 API에 속하지 않는다. 멀티 스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.

다음은 스레드 안전성이 높은 순이다.

- 불변
    - String, Long, BigIntger([item7](7%20%E1%84%83%E1%85%A1%20%E1%84%8A%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8E%E1%85%A1%E1%86%B7%E1%84%8C%E1%85%A9%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%92%E1%85%A2%E1%84%8C%E1%85%A6%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1%20e81799b239c247f1a90cbf3889137af3.md)), ...
- 무조건적 스레드 안전(unconditionally thread-safe)
    - 인스턴스는 수정될 수 있으나, 내부에서 동기화해 별도의 외부 동기화 없이 동시에 사용해도 안전하다.
    - AtomicLong, ConcurrentHashMap ...
- 조건부 스레드 안전(conditionally thread-safe)
    - Collections.synchronized 래퍼 메서드가 반환한 컬렉션들은 동시에 사용하려면 외부 동기화가 필요하다. 이 컬렉션들이 리턴한 반복자는 외부에서 동기화해야한다.
    - 주의해서 문서화해야한다. 어떤 순서로 호출시 외부 동기화가 필요한지 그 순서로 호출하려면 어떤락을 얻어야 하는지 알려줘야한다.
        - Collections.synchronizedMap
- 스레드 안전하지 않음(not thread-safe)
    - 이 클래스 인스턴스는 수정될 수 있고 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야한다.
    - ArrayList, HashMap, ...
- 스레드 절대적(thread-hostile)
    - 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티 스레드 환경에서 안전하지 않다.
    - [item78](78%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%A7%E1%86%AB%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%20af247c2c99a243919593f7c2ab3a5f4d.md)의 generateSerialNumber 메서드에서 내부 동기화를 생략하면 스레드 적대적이게 된다.

**lock 필드는 항상 final로 선언하라**

우연히라도 락 객체가 교체되는 일을 예방한다.

상속용 클래스에서 자신의 인스턴스를 락으로 사용한다면 하위 클래스는 쉽게 시반 클래스의 동작을 방해할 수 있다.

## 정리

모든 클래스가 스레드 안전성 정보를 명확히 문서화해야하며 스레드 안전성 어노테이션을 사용할 수 있다. synchronized한정자는 문서화와 관련이 없ㅅ다. 조건부 스레드 안전 클래스는 메서드를 어떤 순서로 호출시 외부 동기화가 요구되고 어떤 락을 얻어야하는지도 알려줘야한다. 무조건적 스레드 안전 클래스를 작성할땐 synchronized메서드가 아닌 비공개 락객체를 사용하자. 이렇게 해야 클라이언트나 하위 클래스에서 동기화 메커니즘을 깨드리는걸 예방할 수 있고 필요하다면 다음에 더 정교한 동시성 제어 메커니즘으로 재구현할 여지가 생긴다.