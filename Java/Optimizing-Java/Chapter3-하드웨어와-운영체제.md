# 3. 하드웨어와 운영체제

Created: 2020년 8월 18일

무어의 법칙에 따라 트랜지스터 개수가 급증해 **클럭속도 높이기** 했으나, 칩이 빨리진만큼 데이터가 빨라지진 않아서 프로세서 코어의 데이터 수요를 메인 메모리가 맞추기 어려워졌다. 결국 CPU가 놀게됐다.

그래서 CPU 메모리 영역에 있는 `CPU 캐시` 가 나왔다. 레지스터보단 느리지만 메인 메모리보단 빠르다. 
자주 액세스 하는 메모리 위치는 CPU가 메인 메모리를 참조하지 않게 사본떠서 CPU캐시에 보관한다.

일반적으로 전용 프라이빗 캐시 L1, L2, 전체 코어가 공유하는 L3 이렇게 둔다.

메모리에 있는 데이터를 캐시로 가져오거나 캐시한 데이터를 어떻게 메모리에 다시 쓰는 문제 ⇒ `cache consistency protocol` 로 해결

프로세서의 가장 저수준에서 MESI 프로토콜 사용, 캐시라인 상태를 다음  네가지로 정의한다.

- Modified : 데이터 수정됨
- Exclusive : 이 캐시에만 존재하고 메인 메모리 내용과 동일
- Shared : 둘 이상의 캐시에 데이터 있고 메모리 내용과 동일
- Invalid : 다른 프로세스가 데이터 수정해서 무효함

어느 한 프로세서가 Exclusive, Modified 상태로 바뀌면 다른 모든 프로세서는 모두 Invalid 상태가 된다.

프로세서가 처음 나왔을땐 매번 캐시 연산 결과를 메모리에 바로 기록하는 `동시 기록(write through)` 였으나 메모리 대역폭을 너무 많이 써서 지금은 사용하지않는 방식임

지금은 캐시 블록을 교체해도 프로세서가 변경된 캐시 블록만 메모리에 기록하는 `write back` 방식을 써서 메인 메모리로 돌아가는 트래픽을 줄임

메모리 최대 전송률은 다음 인자에 따라 달라짐

- 메모리 클록 주파수
- 메모리 버스 폭
- 인터페이스 개수

DDR RAM(이중 데이터 전송률)은 클록 신호 양단에서 통신하며 최대 전송률이 2배이다.

## 최신 프로세서의 특성

### 변환 색인 버퍼(TLB)

변환 색인 버퍼(traslation lookaside buffer, TLB)는 여러 캐시에서 중요하게 쓰이는 장치이다.

물리 주소 룩업 시간을 줄이는 하드웨어 기능

가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행하므로 작업 속도가 매우 빨라진다.

### 분기 예측과 추측 실행

분기 예측은 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지한다.

프로세서는 트랜지스터를 아낌없이 활용해 가장 발생 가능성이 큰 브랜치를 미리 결정하는 휴리스틱을 형성한다. 틀리면 부분적으로 실행한 명령을 모두 폐기한 후 파이프라인을 비운다.

### 하드웨어 메모리 모델

javac 와 CPU 는 일반적으로 코드 실행 순서를 바꿀 수 있다. 

이런 종류의 순서바꾸기(reordering) 방식은 x86칩에선 불가능하지만 CPU 아키텍처에 따라 조금씩 차이가 있다.

### 운영체제

여러 실행 프로세스가 공유하는 리소스 액세스를 관장하는 역할, CPU, 메모리 리소스 분배

메모리 관리 유닛(**MMU)** 을 통한 가상 주소방식과 페이지 테이블은 메모리 액세스 제어의 핵심으로, 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 훼손하지 못하도록 한다.

하지만 MMU를 조작하기엔 너무 저수준이므로 대신 OS 스케줄러를 조작한다.

### 스케줄러

프로세스 스케줄러는 CPU 엑세스를 통제한다. 이때 `실행 큐` 라는 큐를 이용한다.

스케쥴러는 인터럽트에 응답하고 CPU 코어 엑세스를 관리한다

자바 스레드가 `green thread`를 허용한다고 자바 명세서에는 쓰여있지만 실제로 이 방식이 좋진 않아서 주류 운영환경에선 배제됐다.

OS 스케줄러는 스레드를 시스템 단일 코어로 나르고, 스케줄러는 할당시간 끝 무렵 실행큐로 스레드를 되돌려서 큐의 맨 앞으로  가 다시 실행할 때 까지 대기시킨다.

스레드가 할당받은 시간을 자발적으로 포기하려면 sleep(), wait() 로 대기조건을 명시하거나 software lock에 걸려 블로킹 한다.

OS는 CPU가 대기하도록 하는 시간을 유발한다. 할당 시간을 다 쓴 프로세스는 실행 큐 맨 앞으로 갈 때까지 CPU로 복귀하지 않는다. 즉 CPU에서 코드가 실행되는 시간보다 유휴시간이 더 많다. 그러므로 실제로 관측한 프로세스에서 나온 통계치는 다른 프로세스의 동작에도 영향을 받는다. 이런 **지터와 스케줄링 오버헤드는 측정결과에 노이즈를 만든다.**

스케줄러의 움직임을 확인하는 가장 쉬운 방법은 스케줄링 과정에서 발생시킨 오버헤드를 관측하는것이다

유닉스는 10~20%, 악명높은 윈도우 xp는 180%에 이른다.

### 시간 문제

POSIX이 있어도 OS는 저마다 다르게 동작한다.

## 기본 감지 전략

### CPU 사용률

- **vmstat**
    - 대다수의 os에서 vmstat은 컨텍스트 교환 발생 횟수를 나타내므로 CPU 사용률이 100% 도 아닌데 어떤 프로세스에서 컨텍스트 교환 비율이 높게 나타나면 I/O에서 블로킹이 일어났거나, 쓰레드 락 경합(thread lock contention)이 벌어졌을 가능성이 크다
- **iostat**

### 가비지 수집

가비지 수집엔 커널교환이 필요없다. 따라서 커널 공간의 사용률에는 영향을 미치지 않는다. 반면 JVM이 프로세스가 어떤 유저 영역에서 CPU를 많이 쓰고있다면 GC를 의심해봐야한다.

JVM에서 GC 로깅은 꼭 해야한다.

### 입출력

파일 I/O는 시스템 성능에 암적이다.

자바는 대부분 단순한 I/O만 처리한다.

**커널 바이패스 IO**

- 커널을 이용해 데이터를 복사해 유저공간에 넣는 작업이 비싼 애플리케이션이 있으므로 커널 대신 직접 네트워크 카드에서 유저가 접근 가능한 영역으로 데이터를 매핑하는 전용 hw/sw를 쓴다 이렇게 하면 커널과 유저 사이를 넘나드면서 복사하지 않아도 됨
- 하지만 자바는 이러한 구현체를 제공하지 않으므로 네이티브 라이브러리를 써야한다.
- java NIO와 비슷, 자바IO로 하여금 자바 힙을 통과시켜 네이티브 메모리 및 하부IO와 직접 통신하게 한다는게 비슷함

### 가상화

가상화의 특징

- 베어 메탈(비 가상화 OS)에서 실행할때와 동일하게 작동해야 한다.
- 하이퍼바이저 는 모든 하드웨어 리소스액세스를 조정해야한다
- 가상화 오버헤드는 가급적 작아야하며 실행시간 상당부분을 차지하면 안된다

비 가상화 시스템에서 OS커널은 privileged 모드로 동작하므로 하드웨어를 직접 건드릴 수 있지만 가상화 시스템에선 게스트 OS가 하드웨어에 직접 액세스 할 수 없다

따라서 대개 privileged 명령어를 unprivileged 명령어로 고쳐쓴다.

컨텍스트 교환이 발생하는 동안 지나친 cache flush(TLB)가 일어나지 않도록 일부 OS커널의 자료 구조는 섀도(shadow) 해야한다.

## JVM과 운영체제

JVM은 자바 코드에 공용 인터페이스를 제공해 OS에 독립적인 휴대용 실행 환경을 제공한다.

하지만 스레드 스케쥴링 혹은 시간정보를 얻는 뻔한 작업 같은 기본적인 서비스조차도 하부 OS에 반드시 엑세스해야한다.

이런 기능은 native 키워드를 붙인 네이티브 메서드로 구현한다.이런 인터페이스를 java native interface(JNI)라고 한다.