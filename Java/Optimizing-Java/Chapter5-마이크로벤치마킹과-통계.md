# 5. 마이크로벤치마킹과 통계

Created: 2020년 9월 13일

## 자바 성능 기초

JVM 웜업을 고려해야한다.

JIT 컴파일러는 코드를 효율적으로 작동시키려고 call hierarchy(호출계층)을 최적화한다.

캡처 도중 GC가 일어나서 결과가 크게 나올수도 있으므로 GC가 일어날 가능성이 클때를 피해서 캡쳐하는게 좋다. 

작은  자바 코드 조각보다 자바 애플리케이션 전체를 대상으로 성능 분석을 하는 편이 거의 항상 더 수월하다.

### 마이크로 벤치마킹 시점

주요 유스케이스

- 사용범위가 넓은 범용 라이브러리 코드 개발
- OpneJDK 혹은 자바 구현체 개발
- 지연에 극도로 민감한 코드를 개발

의미있는 결과를 도출하기 위한 조건

- 총 코드 실행시간은 적어도 1밀리초, 100마이크로초보다 짧아야한다
- 메모리 할당률을 측정하는데 그 값은 1mb/s미만, 가급적 0에 가까운 값이어야 한다
- 100% 가깝게 CPU 사용하며 시스템 이용률은 10% 이하여야한다
- 실행 프로파일러로 CPU 를 소비하는 메서드들 분포를 이해해야한다. 보통 두세개정도 된다

## JMH

자바를 비롯해 JVM을 타깃으로 하는 언어로 작성된 나노/마이크로/밀리/매크로 벤치마크를 제작 실행 분석하는 자바 도구

OpenJDK 개발팀이 쓰려고 만든 툴

벤치마크 프레임워크는 컴파일 타임에 벤치마크 내용을 알 수 없으므로 동적이어야 한다. 그래서 JMH는 벤치마크코드에 어노테이션을 붙여 자바소스를 추가 생성하는 식으로 작동한다. 어노테이션 기반의 테스트 프레임워크(JUnit)은 대부분 리플렉션을 사용하기 때문에 추가 소스생성작업에 프로세서를 사용하면서 예기치못한 결과를 초래할 때가 있다.

벤치마크 프레임워크가 유저 코드를 엄청 반복호출할경우 루프 최적화 때문에 벤치마크 코드를 실행하는 실제 프로세스가 결과 신뢰도에 영향을 미칠 가능성이 있다. 이것을 JMH는 벤치마크 코드가 루프 최적화에 걸리지 않을정도로의 반복횟수를 설정한 루프안에 감싸 넣는다.

JVM과 밀접하게 맞닿아 작동하는 몇가지 기능

- 컴파일러를 제어한다
- 벤치마크 도중 CPU 사용 수준을 시뮬레이션 한다

JMH는 blackhole이라는 벤치마크 메서드가 반한환 단일 결괏값을 저장하는 공간이 있다.

벤치마크에 영향을 줄 수 있는 최적화를 위한 blackhole 4가지 장치

- 런타임에 죽은 코드를 제거하는 최적화를 못 하게 한다
- 반복되는 계산을 constant folding(상수폴딩) 하지 않게 한다
- 값을 읽거나 쓰는 행위가 현재 캐시 라인에 영향을 끼치는 잘못된 공유 현상을 방지한다
- write wall(쓰기 장벽) 으로부터 보호한다.
    - wall 이란 리소스가 포화돼서 애플리케이션에서 병목을 초대하는 지점이다

## JVM 성능 통계

### 오차 유형

랜덤오차

- 측정오차 또는 무관계 요인이 상관관계 없이 영향을 미침

계통 오차(systematic error)

- 원인 알수없는 요인이 상관관계있게 영향을 미침