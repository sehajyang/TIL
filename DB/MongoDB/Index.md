# Index

Created: 2021년 6월 27일
Created by: Seha Jyang

**목차**

---

## 인덱싱 핵심 개념

### 단일 인덱스(simpel index)

단일 키에 대해 생성한 인덱스

인덱스 내의 각 엔트리는 인덱스되는 도큐먼트내의 한 값과 일치한다.

### 복합 인덱스(compound index)

각 엔트리가 하나이상의 키로 구성된 인덱스

복합 키를 사용하는 쿼리를 만족시키기 위해선 각 인덱스를 따로 탐색해 일치하는 디스크 위치의 리스트를 합쳐서 교차점(intersection)을 계산해야 하는데 mongodb는 지원하지않는다. 따라서  이런경우엔 복합 인덱스를 써야한다. 

a-b에 대한 복합 인덱스를 갖고있다면 a에 대한 인덱스는 중복이고, b에 대한 인덱스는 중복이 아니다.

복합 키를 사용하는 쿼리에 대해선 복합 인덱스가 적당하다.

순서가 중요하다.

### 인덱스 효율

변경연산이 수행될 때 마다 쓰기 연산 뿐 만 아니라 컬렉션이 갖고있는 인덱스 수 만큼 인덱스가 수정된다.

이렇게 비용이 발생하니 조심해서 생성해야 한다.

인덱스와 현재 작업중인 데이터를 램에서 다 처리할지 못할땐 쿼리를 더 빠르게 처리하지 못할 가능성이 있다.

인덱스와 현재 작업중인 데이터가 모두 램에 존재하는것이 이상적이며 데이터가 램보다 클 경우 점점 페이지 폴트가 발생하다 모든 읽기와 쓰기에 대해 디스크 액세스를 해야하는 `threashing` 이 발생할 수 있다. 이런경우 최소한 인덱스만큼은 램에 들어가도록 해야하며 자주 발생하는 쿼리에 대해 **covering index**를 생성한다면 쿼리가 빨라질 것이다.

`stats` 명령으로 전체 인덱스 크기를 확인할 수 있다.

### **covering index**

인덱스의 한 종류가 아님, 인덱스를 특별하게 사용하는것으로 쿼리가 필요로하는 모든 데이터가 인덱스에 있을떄 "인덱스가 쿼리를 커버한다" 라고 한다.

mongodb에선 인덱스에서 리턴할 필트를 선택하고 id를 제외하면 된다*(*id는 인덱스의 일부로 사용하지 않기 때문)

```json
db.values.find({close:1}, {open:1, close:1, date:1, _id:0})
```

## B-tree

mongodb는 내부적으로 b-tree 인덱스를 생성한다.

각 노드는 8KB의 크기를 갖고있으며 60% 정도만을 사용하도록 기본설정이 되어있다.

## 인덱스 이름

### 와일드카드 필드 이름

`$**` 는 모든 필드를 문자열로 인덱싱한다.

```json
db.books.createIndex(
	{'$**' : 'text'},
	{weights:
		{
			title: 10,
			categories : 5
	}})
```

## 인덱스 타입

### 고유 인덱스(unique index)

 `_id`

`dropDups` 옵션으로 중복된 키 값을 갖는 도큐먼트를 삭제할 수 있다.

### 희소 인덱스(sparse index)

인덱스의 키가 null이 아닌 값을 가지고 있는 도큐먼트만 존재한다.

```json
db.products.createIndex({sku : 1}, {unique : true, sparse : true})
```

컬렉션에서 많은 수의 도큐먼트가 인덱스 키를 갖고있지 않은 경우 유용하다.

3.2 버전 이상부턴 `partial index` 가 더 좋다.

### 다중 키 인덱스(multikey index)

필드의 값이 배열인 경우 적합한 인덱스

단일 키 인덱스 생성보다 비용이 크므로 신중하게 사용해야한다.

[다중키 인덱스]()

### 해시 인덱스(hash index)

해시 인덱스의 엔트리는 균등하게 분배되며 고정길이라는 장점이 있다. 인덱스의 데이터 지역성이 없으므로 샤드 컬렉션에서 유용하다. 

제한사항은 다음과 같다.

- 동등 쿼리(equals query)는 괜찮지만 범위 쿼리는 지원되지 않는다.
- 다중 키 해시 인덱스는 허용되지 않는다.
- **부동 소수점 값은 해시되기 전에 정수로 변환된다**. 따라서 정수로 변환된게 같은 값은 인덱스에서 동일한 값을 갖는다.

### 지리공간적 인덱스(geospatial index)

각 도큐먼트에 저장된 위도, 경도값에 따라 도큐먼트를 특정위치에 가까이 배치한다.

## 인덱스 관리

### 인덱스 생성

`createIndex()` 를 쓰거나 `system.indexes` 에 직접 넣어 생성할 수 있다. 

```json
use green
spec = {ns : green.user, key: {address.zip: 1}, name: zip}
system.indexes.insert(spec)
```

### 인덱스 삭제

`system.indexes` 에서 삭제하는건 금지되어있으며, `dropIndex()` 로 삭제할 수 있다.

```json
// 직접 삭제
use green
db.runCommand({deleteIndexes: users, index: zip})

// 일반적인 방법
use green
db.users.dropIndex(name)
```

### 인덱스 구축

데이터가 대량일 경우 인덱스 구축은 오랜 시간이 걸리며 중지시키기가 어렵다. 이런경우 백업 또는 세컨더리 노드로 서비스 해야할 것이다. 

단계는 다음과 같다.

- 인덱스 할 값을 정렬한다. 서버 로그에서 인덱스 구축을 위해 표시된 진척상황을 볼 수 있다.
- 정렬된 값들이 인덱스로 삽입된다. 구축을 완료하기까지 소요된 시간을 `system.indexes` 에 삽입시간으로 나타낸다. `db.currentOp()` 메서드로도 생성 진척상황을 볼 수 있다.

### 백그라운드 인덱싱

인덱스가 백그라운드에서 구축되도록 설정할 수 있다. 인덱스를 선언할 때 `background:true` 를 지정하면 된다.

### 오프라인 인덱싱

한 복제 노드를 오프라인 상태로 바꾸고, 그 노드에 대해 인덱스를 구축한 다음 마스터 노드로부터 업데이트를 받는다. 

업데이트를 완료하면 이 노드를 프라이머리 노드로 바꾸고 다른 노드는 오프라인으로 바꾼 뒤 인덱스 구축을 한다. 

### 백업

인덱스는 구축하기 어려우므로 백업을 해놔야 하며 mongodump 나 mongorestore를 사용할 수 있는데, 컬렉션과 인덱스의 정의만을 보관하며 실행하면 컬렉션에 대해 정의된 모든 인덱스가 다시 생성된다. 

백업이 인덱스를 포함하길 원한다면 mongodb 데이터 파일 자체를 백업해야 한다.

### defragmenting

기존 데이터의 변경이 자주 발생한다면 인덱스가 심하게 단편화된다. 이런경우 인덱스 재구축을 고려할 수 있으며 명령은 다음과 같다. 

```json
db.values.reIndex();
```

재구축 할땐 쓰기잠금을 하므로 mongodb를 사용할 수 없게되며 오프라인일때 최적으로 수행한다.

## 요약

- 인덱스는 유용하지만 비용이 비싸므로 쓰기가 느려진다.
- mongodb는 쿼리에서 하나의 인덱스만 사용하므로 여러 필드 쿼리에 대한 복합 인덱스는 효율적이어야 한다.
- 복합 인덱스 선언시엔 순서가 중요하다.
- 비용이 많이 드는 쿼리는 피해야하며 explain명령과 쿼리 로그 및 프로파일러로 최적화를 해야한다.
- mongodb 인덱스 생성은 비용이 많이 들며 인덱스를 조기에 만들어야 한다.
- 스캔한 도큐먼트 수를 줄여 쿼리를 최적화해야한다.